/*
 * Copyright 2015-2017 Richard Linsdale.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package uk.theretiredprogrammer.nbpcglibrary.authentication.dataobjects;

import java.text.MessageFormat;
import java.util.ArrayList;
import java.util.List;
import org.openide.util.Lookup;
import org.openide.util.lookup.ServiceProvider;
import static uk.theretiredprogrammer.nbpcglibrary.authentication.dataobjects.User.UserField;
import uk.theretiredprogrammer.nbpcglibrary.api.*;
import uk.theretiredprogrammer.nbpcglibrary.common.*;
import uk.theretiredprogrammer.nbpcglibrary.data.entity.*;
import uk.theretiredprogrammer.nbpcglibrary.data.entityreferences.*;

/**
 * The User Entity.
 *
 * (Class generated by NetBeans Platform Code Generator tools using script.xml.
 * Do not edit this file. Apply any changes to the definition file and
 * regenerate all files.)
 *
 * @author Richard Linsdale (richard at theretiredprogrammer.uk)
 */
public class User extends Entity<Integer, User, UserRoot, UserField> {

    /**
     * the User field identifiers
     */
    public enum UserField {
        /**
         * the username field
         */
        USERNAME,
        /**
         * the encodedpassword field
         */
        ENCODEDPASSWORD,
        /**
         * the usercode field
         */
        USERCODE,
        /**
         * the enabled field
         */
        ENABLED,
        /**
         * the userpermissions collection
         */
        USERPERMISSIONS,
        /**
         * the userroles collection
         */
        USERROLES,
    }
    
    private final Rules entityRules = new Rules();
    private final UserRoot root;
    private String username = "";
    private String usernameOriginal;
    private final Rules usernameRules = new Rules();
    private String encodedpassword = "";
    private String encodedpasswordOriginal;
    private final Rules encodedpasswordRules = new Rules();
    private String usercode = "";
    private String usercodeOriginal;
    private final Rules usercodeRules = new Rules();
    private boolean enabled = false;
    private boolean enabledOriginal;
    private final Rules enabledRules = new Rules();
    private int id = 0;
    private String createdby = "";
    private final Timestamp createdon = new Timestamp();
    private String updatedby = "";
    private final Timestamp updatedon = new Timestamp();
    private final EntityReferenceFilterSet<Integer, Userpermission, User> userpermissions;
    private final EntityReferenceFilterSet<Integer, Userrole, User> userroles;

    /**
     * Constructor - User.
     *
     * @param id the unique id for this entity
     * @param em - the entity manager for this entity type
     */
    public User(int id, User.EM em) {
        super("User[" + Integer.toString(id) + "]", "user", em);
        this.id = id;
        root = UserRoot.get();
        addRule(usernameRules, new UsernameMinRule());
        addRule(usernameRules, new UsernameMaxRule());
        addRule(usernameRules, new UsernameUniqueRule());
        addRule(encodedpasswordRules, new EncodedpasswordMinRule());
        addRule(encodedpasswordRules, new EncodedpasswordMaxRule());
        addRule(usercodeRules, new UsercodeMinRule());
        addRule(usercodeRules, new UsercodeMaxRule());
        addRule(usercodeRules, new UsercodeUniqueRule());
        userpermissions = new EntityReferenceFilterSet<>(instanceDescription() + ">Userpermissions", "user", getId(), Userpermission.EM.class);
        userpermissions.load();
        userroles = new EntityReferenceFilterSet<>(instanceDescription() + ">Userroles", "user", getId(), Userrole.EM.class);
        userroles.load();
        checkRulesAtLoad(new StringBuilder());
    }
    
    @Override
    public boolean isPersistent() {
        return id > 0;
    }
    
    @Override
    public final Integer getPK() {
        return getId();
    }

    /**
     * Get all rules for this entity
     *
     * @return the set of rules
     */
    public final Rules getEntityRules() {
        return entityRules;
    }
    
    @Override
    public final String instanceDescription() {
        return "".equals(username)
                ? LogBuilder.instanceDescription(this, Integer.toString(getId()))
                : LogBuilder.instanceDescription(this, Integer.toString(getId()) + "-" + username);
    }
    
    private class UsernameMinRule extends Rule {
        
        public UsernameMinRule() {
            super("Too short");
        }
        
        @Override
        public boolean ruleCheck() {
            return username.length() >= 1;
        }
    }
    
    private class UsernameMaxRule extends Rule {
        
        public UsernameMaxRule() {
            super("Too long");
        }
        
        @Override
        public boolean ruleCheck() {
            return username.length() <= 100;
        }
    }
    
    private class UsernameUniqueRule extends UniqueRule {
        
        public UsernameUniqueRule() {
            super("username is not unique");
        }
        
        @Override
        protected boolean ruleCheck() {
            return getParent().getUsers().stream().noneMatch((e) -> (e != User.this && e.getUsername().equals(username)));
        }
    }
    
    private class EncodedpasswordMinRule extends Rule {
        
        public EncodedpasswordMinRule() {
            super("Too short");
        }
        
        @Override
        public boolean ruleCheck() {
            return encodedpassword.length() >= 40;
        }
    }
    
    private class EncodedpasswordMaxRule extends Rule {
        
        public EncodedpasswordMaxRule() {
            super("Too long");
        }
        
        @Override
        public boolean ruleCheck() {
            return encodedpassword.length() <= 40;
        }
    }
    
    private class UsercodeMinRule extends Rule {
        
        public UsercodeMinRule() {
            super("Too short");
        }
        
        @Override
        public boolean ruleCheck() {
            return usercode.length() >= 4;
        }
    }
    
    private class UsercodeMaxRule extends Rule {
        
        public UsercodeMaxRule() {
            super("Too long");
        }
        
        @Override
        public boolean ruleCheck() {
            return usercode.length() <= 4;
        }
    }
    
    private class UsercodeUniqueRule extends UniqueRule {
        
        public UsercodeUniqueRule() {
            super("usercode is not unique");
        }
        
        @Override
        protected boolean ruleCheck() {
            return getParent().getUsers().stream().noneMatch((e) -> (e != User.this && e.getUsercode().equals(usercode)));
        }
    }

    /**
     * Get the parent Entity associated with this entity.
     *
     * @return the Root entity
     */
    public UserRoot getParent() {
        return root;
    }

    private void fireNameAndOrTitleChangeOnRoot() {
    }

    /**
     * Get the username field rules.
     *
     * @return the rules
     */
    public Rules getUsernameRules() {
        return usernameRules;
    }

    /**
     * Get the username.
     *
     * @return the username
     */
    public final String getUsername() {
        return username;
    }

    /**
     * Define the Username.
     *
     * @param username the username
     */
    public void setUsername(String username) {
        if (!this.username.equals(username)) {
            ensureEditing();
            this.username = username;
            fireFieldChange(UserField.USERNAME);
            fireNameAndOrTitleChangeOnUsername();
        }
    }

    private void fireNameAndOrTitleChangeOnUsername() {
        nameListenerFire();
        titleListenerFire();
    }

    /**
     * Get the encodedpassword field rules.
     *
     * @return the rules
     */
    public Rules getEncodedpasswordRules() {
        return encodedpasswordRules;
    }

    /**
     * Get the encodedpassword.
     *
     * @return the encodedpassword
     */
    public final String getEncodedpassword() {
        return encodedpassword;
    }

    /**
     * Define the Encodedpassword.
     *
     * @param encodedpassword the encodedpassword
     */
    public void setEncodedpassword(String encodedpassword) {
        if (!this.encodedpassword.equals(encodedpassword)) {
            ensureEditing();
            this.encodedpassword = encodedpassword;
            fireFieldChange(UserField.ENCODEDPASSWORD);
            fireNameAndOrTitleChangeOnEncodedpassword();
        }
    }

    private void fireNameAndOrTitleChangeOnEncodedpassword() {
    }

    /**
     * Get the usercode field rules.
     *
     * @return the rules
     */
    public Rules getUsercodeRules() {
        return usercodeRules;
    }

    /**
     * Get the usercode.
     *
     * @return the usercode
     */
    public final String getUsercode() {
        return usercode;
    }

    /**
     * Define the Usercode.
     *
     * @param usercode the usercode
     */
    public void setUsercode(String usercode) {
        if (!this.usercode.equals(usercode)) {
            ensureEditing();
            this.usercode = usercode;
            fireFieldChange(UserField.USERCODE);
            fireNameAndOrTitleChangeOnUsercode();
        }
    }

    private void fireNameAndOrTitleChangeOnUsercode() {
    }

    /**
     * Get the enabled field rules.
     *
     * @return the rules
     */
    public Rules getEnabledRules() {
        return enabledRules;
    }

    /**
     * Get the enabled.
     *
     * @return the enabled
     */
    public final boolean getEnabled() {
        return enabled;
    }

    /**
     * Define the Enabled.
     *
     * @param enabled the enabled
     */
    public void setEnabled(boolean enabled) {
        if (this.enabled != enabled) {
            ensureEditing();
            this.enabled = enabled;
            fireFieldChange(UserField.ENABLED);
            fireNameAndOrTitleChangeOnEnabled();
        }
    }

    private void fireNameAndOrTitleChangeOnEnabled() {
    }

    /**
     * Get the id.
     *
     * @return the id
     */
    public final int getId() {
        return id;
    }

    /**
     * Get the createdby.
     *
     * @return the createdby
     */
    public final String getCreatedby() {
        return createdby;
    }

    /**
     * Get the createdon.
     *
     * @return the createdon
     */
    public final Timestamp getCreatedon() {
        return createdon;
    }

    /**
     * Get the updatedby.
     *
     * @return the updatedby
     */
    public final String getUpdatedby() {
        return updatedby;
    }

    /**
     * Get the updatedon.
     *
     * @return the updatedon
     */
    public final Timestamp getUpdatedon() {
        return updatedon;
    }

    /**
     * Add a Userpermission to this entity.
     *
     * @param e the userpermission
     */
    public void addUserpermission(Userpermission e) {
        e.linkToParent(this);
        userpermissions.add(e);
    }

    /**
     * Remove a Userpermission from this entity.
     *
     * @param e the userpermission
     */
    public void removeUserpermission(Userpermission e) {
        e.unlinkFromParent();
        userpermissions.remove(e);
    }

    /**
     * Add set listener to userpermissions collections
     *
     * @param listener the set change listener to add
     */
    public void addUserpermissionSetChangeListener(Listener<SetChangeEventParams> listener) {
        userpermissions.addSetListener(listener);
    }

    /**
     * remove set listener to userpermissions collections
     *
     * @param listener the set change listener to add
     */
    public void removeUserpermissionSetChangeListener(Listener<SetChangeEventParams> listener) {
        userpermissions.removeSetListener(listener);
    }

    /**
     * Add set listener to all userpermissions (and parent) collections
     *
     * @param listener the set change listener to add
     */
    public static void addUserpermissionsSetChangeListeners(Listener<SetChangeEventParams> listener) {
        User.getAllUsers().stream().forEach((user) -> {
            ((User) user).addUserpermissionSetChangeListener(listener);
        });
        UserRoot.addUsersSetChangeListeners(listener);
    }

    /**
     * Remove set listener from all userpermissions (and parent) collections
     *
     * @param listener the set change listener to remove
     */
    public static void removeUserpermissionsSetChangeListeners(Listener<SetChangeEventParams> listener) {
        User.getAllUsers().stream().forEach((user) -> {
            ((User) user).removeUserpermissionSetChangeListener(listener);
        });
        UserRoot.removeUsersSetChangeListeners(listener);
    }

    /**
     * Get List of userpermissions associated with entity.
     *
     * @return list of userpermissions
     */
    public List<Userpermission> getUserpermissions() {        
        return userpermissions.get();
    }

    /**
     * Add a Userrole to this entity.
     *
     * @param e the userrole
     */
    public void addUserrole(Userrole e) {
        e.linkToParent(this);
        userroles.add(e);
    }

    /**
     * Remove a Userrole from this entity.
     *
     * @param e the userrole
     */
    public void removeUserrole(Userrole e) {
        e.unlinkFromParent();
        userroles.remove(e);
    }

    /**
     * Add set listener to userroles collections
     *
     * @param listener the set change listener to add
     */
    public void addUserroleSetChangeListener(Listener<SetChangeEventParams> listener) {
        userroles.addSetListener(listener);
    }

    /**
     * remove set listener to userroles collections
     *
     * @param listener the set change listener to add
     */
    public void removeUserroleSetChangeListener(Listener<SetChangeEventParams> listener) {
        userroles.removeSetListener(listener);
    }

    /**
     * Add set listener to all userroles (and parent) collections
     *
     * @param listener the set change listener to add
     */
    public static void addUserrolesSetChangeListeners(Listener<SetChangeEventParams> listener) {
        User.getAllUsers().stream().forEach((user) -> {
            ((User) user).addUserroleSetChangeListener(listener);
        });
        UserRoot.addUsersSetChangeListeners(listener);
    }

    /**
     * Remove set listener from all userroles (and parent) collections
     *
     * @param listener the set change listener to remove
     */
    public static void removeUserrolesSetChangeListeners(Listener<SetChangeEventParams> listener) {
        User.getAllUsers().stream().forEach((user) -> {
            ((User) user).removeUserroleSetChangeListener(listener);
        });
        UserRoot.removeUsersSetChangeListeners(listener);
    }

    /**
     * Get List of userroles associated with entity.
     *
     * @return list of userroles
     */
    public List<Userrole> getUserroles() {        
        return userroles.get();
    }
    
    @Override
    protected final void entitySaveState() {
        usernameOriginal = username;
        encodedpasswordOriginal = encodedpassword;
        usercodeOriginal = usercode;
        enabledOriginal = enabled;
    }
    
    @Override
    protected final void entityRestoreState() {
        username = usernameOriginal;
        encodedpassword = encodedpasswordOriginal;
        usercode = usercodeOriginal;
        enabled = enabledOriginal;
        userpermissions.restoreState();
        userroles.restoreState();
    }
    
    @Override
    protected final void entityRemove() {
        getUserpermissions().stream().forEach((userpermission) -> {
            userpermission.remove();
        });
        getUserroles().stream().forEach((userrole) -> {
            userrole.remove();
        });
        getParent().removeUser(this);
    }
    
    @Override
    protected final void entityLoad(EntityFields data) {
        username = (String) data.get("username");
        encodedpassword = (String) data.get("encodedpassword");
        usercode = (String) data.get("usercode");
        enabled = (Boolean) data.get("enabled");
        id = (Integer) data.get("id");
        createdby = (String) data.get("createdby");
        try {
            createdon.setDateUsingSQLString((String) data.get("createdon"));
        } catch (BadFormatException ex) {
            throw new LogicException("Load reported bad Timestamp format - should never happen!!");
        }
        updatedby = (String) data.get("updatedby");
        try {
            updatedon.setDateUsingSQLString((String) data.get("updatedon"));
        } catch (BadFormatException ex) {
            throw new LogicException("Load reported bad Timestamp format - should never happen!!");
        }
    }
    
    @Override
    protected final void entityCopy(User from) {
        username = from.getUsername();
        encodedpassword = from.getEncodedpassword();
        usercode = from.getUsercode();
        enabled = from.getEnabled();
    }
    
    @Override
    protected final boolean entityDiffs(EntityFields data) {
        if (!username.equals(usernameOriginal)) {
            data.put("username", username);
        }
        if (!encodedpassword.equals(encodedpasswordOriginal)) {
            data.put("encodedpassword", encodedpassword);
        }
        if (!usercode.equals(usercodeOriginal)) {
            data.put("usercode", usercode);
        }
        if (enabled != enabledOriginal) {
            data.put("enabled", enabled);
        }
        return true;
    }
    
    @Override
    protected final boolean entityValues(EntityFields data) {
        data.put("username", username);
        data.put("encodedpassword", encodedpassword);
        data.put("usercode", usercode);
        data.put("enabled", enabled);
        return true;
    }

    /**
     * Get the User Entity Manager
     *
     * @return the User Entity Manager
     */
    public static User.EM getEM() {
        return Lookup.getDefault().lookup(User.EM.class);
    }

    /**
     * The User Entity Manager
     */
    @ServiceProvider(service = User.EM.class)
    public static class EM extends EntityManager<Integer, User, UserRoot> {
        
        private static int tpk = -1;

        /**
         * Constructor.
         */
        public EM() {
            super("User");
        }
        
        @Override
        protected final void link2parent(User e, UserRoot parent) {
            parent.addUser(e);
        }
        
        @Override
        protected final User createNewEntity() {
            return new User(tpk--, this);
        }
        
        @Override
        protected final User createNewEntity(Integer pk) {
            return new User(pk, this);
        }
        
        @Override
        protected final EntityPersistenceProvider createEntityPersistenceProvider() {
            return EntityPersistenceProviderManager.getEntityPersistenceProvider("authentication", "User");
        }
        
        @Override
        protected boolean isPersistent(Integer pkey) {
            return pkey > 0;
        }
    }

    /**
     * Get the set of all Users.
     *
     * @return the set of all Users
     */
    public static List<User> getAllUsers() {
        List<User> list = new ArrayList<>();
        list.addAll(UserRoot.get().getUsers());
        return list;
    }
    
    @Override
    public String getDisplayName() {
        return MessageFormat.format("{0}", formatUsername());
    }
    
    @Override
    public String getDisplayTitle() {
        return getDisplayName();
    }
    
    @Override
    public String getSortKey() {
        return getDisplayTitle();
    }

    /**
     * Get the formatted text version of username field
     *
     * @return the formatted String
     */
    public String formatUsername() {
        return getUsername();
    }

    /**
     * Get the formatted text version of encodedpassword field
     *
     * @return the formatted String
     */
    public String formatEncodedpassword() {
        return getEncodedpassword();
    }

    /**
     * Get the formatted text version of usercode field
     *
     * @return the formatted String
     */
    public String formatUsercode() {
        return getUsercode();
    }

    /**
     * Get the formatted text version of enabled field
     *
     * @return the formatted String
     */
    public String formatEnabled() {
        return getEnabled() ? "Yes" : "No";
    }

    /**
     * Get the formatted text version of id field
     *
     * @return the formatted String
     */
    public String formatId() {
        return Integer.toString(getId());
    }

    /**
     * Get the formatted text version of createdby field
     *
     * @return the formatted String
     */
    public String formatCreatedby() {
        return getCreatedby();
    }

    /**
     * Get the formatted text version of createdon field
     *
     * @return the formatted String
     */
    public String formatCreatedon() {
        return getCreatedon().toString();
    }

    /**
     * Get the formatted text version of updatedby field
     *
     * @return the formatted String
     */
    public String formatUpdatedby() {
        return getUpdatedby();
    }

    /**
     * Get the formatted text version of updatedon field
     *
     * @return the formatted String
     */
    public String formatUpdatedon() {
        return getUpdatedon().toString();
    }

    /**
     * Get the formatted text version of username field left padded with zeros
     * if less than minimum size.
     *
     * @param minChars minimum size
     * @return the formatted String
     */
    public String formatUsername(int minChars) {
        return StringX.padLeftIfInt(formatUsername(), minChars, '0');
    }

    /**
     * Get the formatted text version of encodedpassword field left padded with
     * zeros if less than minimum size.
     *
     * @param minChars minimum size
     * @return the formatted String
     */
    public String formatEncodedpassword(int minChars) {
        return StringX.padLeftIfInt(formatEncodedpassword(), minChars, '0');
    }

    /**
     * Get the formatted text version of usercode field left padded with zeros
     * if less than minimum size.
     *
     * @param minChars minimum size
     * @return the formatted String
     */
    public String formatUsercode(int minChars) {
        return StringX.padLeftIfInt(formatUsercode(), minChars, '0');
    }

    /**
     * Get the formatted text version of id field left padded with zeros if less
     * than minimum size.
     *
     * @param minDigits minimum size
     * @return the formatted String
     */
    public String formatId(int minDigits) {
        return StringX.padLeft(formatId(), minDigits, '0');
    }

    /**
     * Get the formatted text version of createdby field left padded with zeros
     * if less than minimum size.
     *
     * @param minChars minimum size
     * @return the formatted String
     */
    public String formatCreatedby(int minChars) {
        return StringX.padLeftIfInt(formatCreatedby(), minChars, '0');
    }

    /**
     * Get the formatted text version of updatedby field left padded with zeros
     * if less than minimum size.
     *
     * @param minChars minimum size
     * @return the formatted String
     */
    public String formatUpdatedby(int minChars) {
        return StringX.padLeftIfInt(formatUpdatedby(), minChars, '0');
    }
}
