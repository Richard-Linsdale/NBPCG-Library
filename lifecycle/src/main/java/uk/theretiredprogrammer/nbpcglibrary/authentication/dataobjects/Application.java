/*
 * Copyright 2015-2017 Richard Linsdale.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package uk.theretiredprogrammer.nbpcglibrary.authentication.dataobjects;

import java.text.MessageFormat;
import java.util.ArrayList;
import java.util.List;
import org.openide.util.Lookup;
import org.openide.util.lookup.ServiceProvider;
import static uk.theretiredprogrammer.nbpcglibrary.authentication.dataobjects.Application.ApplicationField;
import uk.theretiredprogrammer.nbpcglibrary.api.*;
import uk.theretiredprogrammer.nbpcglibrary.common.*;
import uk.theretiredprogrammer.nbpcglibrary.data.entity.*;
import uk.theretiredprogrammer.nbpcglibrary.data.entityreferences.*;

/**
 * The Application Entity.
 *
 * (Class generated by NetBeans Platform Code Generator tools using script.xml.
 * Do not edit this file. Apply any changes to the definition file and
 * regenerate all files.)
 *
 * @author Richard Linsdale (richard at theretiredprogrammer.uk)
 */
public class Application extends Entity<Integer, Application, ApplicationRoot, ApplicationField> {

    /**
     * the Application field identifiers
     */
    public enum ApplicationField {
        /**
         * the application field
         */
        APPLICATION,
        /**
         * the roles collection
         */
        ROLES,
        /**
         * the permissions collection
         */
        PERMISSIONS,
    }
    
    private final Rules entityRules = new Rules();
    private final ApplicationRoot root;
    private String application = "";
    private String applicationOriginal;
    private final Rules applicationRules = new Rules();
    private int id = 0;
    private String createdby = "";
    private final Timestamp createdon = new Timestamp();
    private String updatedby = "";
    private final Timestamp updatedon = new Timestamp();
    private final EntityReferenceFilterSet<Integer, Role, Application> roles;
    private final EntityReferenceFilterSet<Integer, Permission, Application> permissions;

    /**
     * Constructor - Application.
     *
     * @param id the unique id for this entity
     * @param em - the entity manager for this entity type
     */
    public Application(int id, Application.EM em) {
        super("Application[" + Integer.toString(id) + "]", "application", em);
        this.id = id;
        root = ApplicationRoot.get();
        addRule(applicationRules, new ApplicationMinRule());
        addRule(applicationRules, new ApplicationMaxRule());
        addRule(applicationRules, new ApplicationUniqueRule());
        roles = new EntityReferenceFilterSet<>(instanceDescription() + ">Roles", "application", getId(), Role.EM.class);
        roles.load();
        permissions = new EntityReferenceFilterSet<>(instanceDescription() + ">Permissions", "application", getId(), Permission.EM.class);
        permissions.load();
        checkRulesAtLoad(new StringBuilder());
    }
    
    @Override
    public boolean isPersistent() {
        return id > 0;
    }
    
    @Override
    public final Integer getPK() {
        return getId();
    }

    /**
     * Get all rules for this entity
     *
     * @return the set of rules
     */
    public final Rules getEntityRules() {
        return entityRules;
    }
    
    @Override
    public final String instanceDescription() {
        return "".equals(application)
                ? LogBuilder.instanceDescription(this, Integer.toString(getId()))
                : LogBuilder.instanceDescription(this, Integer.toString(getId()) + "-" + application);
    }
    
    private class ApplicationMinRule extends Rule {
        
        public ApplicationMinRule() {
            super("Too short");
        }
        
        @Override
        public boolean ruleCheck() {
            return application.length() >= 1;
        }
    }
    
    private class ApplicationMaxRule extends Rule {
        
        public ApplicationMaxRule() {
            super("Too long");
        }
        
        @Override
        public boolean ruleCheck() {
            return application.length() <= 100;
        }
    }
    
    private class ApplicationUniqueRule extends UniqueRule {
        
        public ApplicationUniqueRule() {
            super("application is not unique");
        }
        
        @Override
        protected boolean ruleCheck() {
            return getParent().getApplications().stream().noneMatch((e) -> (e != Application.this && e.getApplication().equals(application)));
        }
    }

    /**
     * Get the parent Entity associated with this entity.
     *
     * @return the Root entity
     */
    public ApplicationRoot getParent() {
        return root;
    }

    private void fireNameAndOrTitleChangeOnRoot() {
    }

    /**
     * Get the application field rules.
     *
     * @return the rules
     */
    public Rules getApplicationRules() {
        return applicationRules;
    }

    /**
     * Get the application.
     *
     * @return the application
     */
    public final String getApplication() {
        return application;
    }

    /**
     * Define the Application.
     *
     * @param application the application
     */
    public void setApplication(String application) {
        if (!this.application.equals(application)) {
            ensureEditing();
            this.application = application;
            fireFieldChange(ApplicationField.APPLICATION);
            fireNameAndOrTitleChangeOnApplication();
        }
    }

    private void fireNameAndOrTitleChangeOnApplication() {
        nameListenerFire();
        titleListenerFire();
    }

    /**
     * Get the id.
     *
     * @return the id
     */
    public final int getId() {
        return id;
    }

    /**
     * Get the createdby.
     *
     * @return the createdby
     */
    public final String getCreatedby() {
        return createdby;
    }

    /**
     * Get the createdon.
     *
     * @return the createdon
     */
    public final Timestamp getCreatedon() {
        return createdon;
    }

    /**
     * Get the updatedby.
     *
     * @return the updatedby
     */
    public final String getUpdatedby() {
        return updatedby;
    }

    /**
     * Get the updatedon.
     *
     * @return the updatedon
     */
    public final Timestamp getUpdatedon() {
        return updatedon;
    }

    /**
     * Add a Role to this entity.
     *
     * @param e the role
     */
    public void addRole(Role e) {
        e.linkToParent(this);
        roles.add(e);
    }

    /**
     * Remove a Role from this entity.
     *
     * @param e the role
     */
    public void removeRole(Role e) {
        e.unlinkFromParent();
        roles.remove(e);
    }

    /**
     * Add set listener to roles collections
     *
     * @param listener the set change listener to add
     */
    public void addRoleSetChangeListener(Listener<SetChangeEventParams> listener) {
        roles.addSetListener(listener);
    }

    /**
     * remove set listener to roles collections
     *
     * @param listener the set change listener to add
     */
    public void removeRoleSetChangeListener(Listener<SetChangeEventParams> listener) {
        roles.removeSetListener(listener);
    }

    /**
     * Add set listener to all roles (and parent) collections
     *
     * @param listener the set change listener to add
     */
    public static void addRolesSetChangeListeners(Listener<SetChangeEventParams> listener) {
        Application.getAllApplications().stream().forEach((application) -> {
            ((Application) application).addRoleSetChangeListener(listener);
        });
        ApplicationRoot.addApplicationsSetChangeListeners(listener);
    }

    /**
     * Remove set listener from all roles (and parent) collections
     *
     * @param listener the set change listener to remove
     */
    public static void removeRolesSetChangeListeners(Listener<SetChangeEventParams> listener) {
        Application.getAllApplications().stream().forEach((application) -> {
            ((Application) application).removeRoleSetChangeListener(listener);
        });
        ApplicationRoot.removeApplicationsSetChangeListeners(listener);
    }

    /**
     * Get List of roles associated with entity.
     *
     * @return list of roles
     */
    public List<Role> getRoles() {        
        return roles.get();
    }

    /**
     * Add a Permission to this entity.
     *
     * @param e the permission
     */
    public void addPermission(Permission e) {
        e.linkToParent(this);
        permissions.add(e);
    }

    /**
     * Remove a Permission from this entity.
     *
     * @param e the permission
     */
    public void removePermission(Permission e) {
        e.unlinkFromParent();
        permissions.remove(e);
    }

    /**
     * Add set listener to permissions collections
     *
     * @param listener the set change listener to add
     */
    public void addPermissionSetChangeListener(Listener<SetChangeEventParams> listener) {
        permissions.addSetListener(listener);
    }

    /**
     * remove set listener to permissions collections
     *
     * @param listener the set change listener to add
     */
    public void removePermissionSetChangeListener(Listener<SetChangeEventParams> listener) {
        permissions.removeSetListener(listener);
    }

    /**
     * Add set listener to all permissions (and parent) collections
     *
     * @param listener the set change listener to add
     */
    public static void addPermissionsSetChangeListeners(Listener<SetChangeEventParams> listener) {
        Application.getAllApplications().stream().forEach((application) -> {
            ((Application) application).addPermissionSetChangeListener(listener);
        });
        ApplicationRoot.addApplicationsSetChangeListeners(listener);
    }

    /**
     * Remove set listener from all permissions (and parent) collections
     *
     * @param listener the set change listener to remove
     */
    public static void removePermissionsSetChangeListeners(Listener<SetChangeEventParams> listener) {
        Application.getAllApplications().stream().forEach((application) -> {
            ((Application) application).removePermissionSetChangeListener(listener);
        });
        ApplicationRoot.removeApplicationsSetChangeListeners(listener);
    }

    /**
     * Get List of permissions associated with entity.
     *
     * @return list of permissions
     */
    public List<Permission> getPermissions() {        
        return permissions.get();
    }
    
    @Override
    protected final void entitySaveState() {
        applicationOriginal = application;
    }
    
    @Override
    protected final void entityRestoreState() {
        application = applicationOriginal;
        roles.restoreState();
        permissions.restoreState();
    }
    
    @Override
    protected final void entityRemove() {
        getRoles().stream().forEach((role) -> {
            role.remove();
        });
        getPermissions().stream().forEach((permission) -> {
            permission.remove();
        });
        getParent().removeApplication(this);
    }
    
    @Override
    protected final void entityLoad(EntityFields data) {
        application = (String) data.get("application");
        id = (Integer) data.get("id");
        createdby = (String) data.get("createdby");
        try {
            createdon.setDateUsingSQLString((String) data.get("createdon"));
        } catch (BadFormatException ex) {
            throw new LogicException("Load reported bad Timestamp format - should never happen!!");
        }
        updatedby = (String) data.get("updatedby");
        try {
            updatedon.setDateUsingSQLString((String) data.get("updatedon"));
        } catch (BadFormatException ex) {
            throw new LogicException("Load reported bad Timestamp format - should never happen!!");
        }
    }
    
    @Override
    protected final void entityCopy(Application from) {
        application = from.getApplication();
    }
    
    @Override
    protected final boolean entityDiffs(EntityFields data) {
        if (!application.equals(applicationOriginal)) {
            data.put("application", application);
        }
        return true;
    }
    
    @Override
    protected final boolean entityValues(EntityFields data) {
        data.put("application", application);
        return true;
    }

    /**
     * Get the Application Entity Manager
     *
     * @return the Application Entity Manager
     */
    public static Application.EM getEM() {
        return Lookup.getDefault().lookup(Application.EM.class);
    }

    /**
     * The Application Entity Manager
     */
    @ServiceProvider(service = Application.EM.class)
    public static class EM extends EntityManager<Integer, Application, ApplicationRoot> {
        
        private static int tpk = -1;

        /**
         * Constructor.
         */
        public EM() {
            super("Application");
        }
        
        @Override
        protected final void link2parent(Application e, ApplicationRoot parent) {
            parent.addApplication(e);
        }
        
        @Override
        protected final Application createNewEntity() {
            return new Application(tpk--, this);
        }
        
        @Override
        protected final Application createNewEntity(Integer pk) {
            return new Application(pk, this);
        }
        
        @Override
        protected final EntityPersistenceProvider createEntityPersistenceProvider() {
            return EntityPersistenceProviderManager.getEntityPersistenceProvider("authentication", "Application");
        }
        
        @Override
        protected boolean isPersistent(Integer pkey) {
            return pkey > 0;
        }
    }

    /**
     * Get the set of all Applications.
     *
     * @return the set of all Applications
     */
    public static List<Application> getAllApplications() {
        List<Application> list = new ArrayList<>();
        list.addAll(ApplicationRoot.get().getApplications());
        return list;
    }
    
    @Override
    public String getDisplayName() {
        return MessageFormat.format("{0}", formatApplication());
    }
    
    @Override
    public String getDisplayTitle() {
        return getDisplayName();
    }
    
    @Override
    public String getSortKey() {
        return getDisplayTitle();
    }

    /**
     * Get the formatted text version of application field
     *
     * @return the formatted String
     */
    public String formatApplication() {
        return getApplication();
    }

    /**
     * Get the formatted text version of id field
     *
     * @return the formatted String
     */
    public String formatId() {
        return Integer.toString(getId());
    }

    /**
     * Get the formatted text version of createdby field
     *
     * @return the formatted String
     */
    public String formatCreatedby() {
        return getCreatedby();
    }

    /**
     * Get the formatted text version of createdon field
     *
     * @return the formatted String
     */
    public String formatCreatedon() {
        return getCreatedon().toString();
    }

    /**
     * Get the formatted text version of updatedby field
     *
     * @return the formatted String
     */
    public String formatUpdatedby() {
        return getUpdatedby();
    }

    /**
     * Get the formatted text version of updatedon field
     *
     * @return the formatted String
     */
    public String formatUpdatedon() {
        return getUpdatedon().toString();
    }

    /**
     * Get the formatted text version of application field left padded with
     * zeros if less than minimum size.
     *
     * @param minChars minimum size
     * @return the formatted String
     */
    public String formatApplication(int minChars) {
        return StringX.padLeftIfInt(formatApplication(), minChars, '0');
    }

    /**
     * Get the formatted text version of id field left padded with zeros if less
     * than minimum size.
     *
     * @param minDigits minimum size
     * @return the formatted String
     */
    public String formatId(int minDigits) {
        return StringX.padLeft(formatId(), minDigits, '0');
    }

    /**
     * Get the formatted text version of createdby field left padded with zeros
     * if less than minimum size.
     *
     * @param minChars minimum size
     * @return the formatted String
     */
    public String formatCreatedby(int minChars) {
        return StringX.padLeftIfInt(formatCreatedby(), minChars, '0');
    }

    /**
     * Get the formatted text version of updatedby field left padded with zeros
     * if less than minimum size.
     *
     * @param minChars minimum size
     * @return the formatted String
     */
    public String formatUpdatedby(int minChars) {
        return StringX.padLeftIfInt(formatUpdatedby(), minChars, '0');
    }
}
